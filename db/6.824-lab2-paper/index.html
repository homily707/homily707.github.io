<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>6.824 Lab2 Paper | 斯是陋室</title><meta name=keywords content><meta name=description content="replicated state machines 多个状态机保持相同的状态
实现，通过日志，按顺序保存command。先复制，再执行
非拜占庭问题下正常工作 多数节点可用时整体可用 paxos 缺点 难以理解、不好实现
设计 分解、减少状态
algorithm basics 最少5个节点 三种节点 leader、follower、candidate 每一次选举都是一次term，选举失败也算一次。 每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower RPC 有两种vote、 append 、 （retry） 选主 心跳 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）
election timeout，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时
选举，每个节点投票给第一个找自己竞选的，参选者投自己。
收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。
如果超时，增加term，重新竞选。
防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout
日志复制 先群发 appendRpc。超过半数确认，然后commit。append中下发commited index 超时无响应，重发
日志信息保存term
append 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受 主节点被拒绝后，会减小index
当主节点出错时，新任leader强制以自己的log为准 主节点保存所有从的 nextIndex
Safety 之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。
这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。 并且精细了commit的规则 最后，给出了证明
5.4.1 election restriction 有主节点的共识算法，主节点必须存储所有已提交entries。
Raft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他"><meta name=author content="homily"><link rel=canonical href=https://homily707.github.io/db/6.824-lab2-paper/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://homily707.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://homily707.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://homily707.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://homily707.github.io/apple-touch-icon.png><link rel=mask-icon href=https://homily707.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="6.824 Lab2 Paper"><meta property="og:description" content="replicated state machines 多个状态机保持相同的状态
实现，通过日志，按顺序保存command。先复制，再执行
非拜占庭问题下正常工作 多数节点可用时整体可用 paxos 缺点 难以理解、不好实现
设计 分解、减少状态
algorithm basics 最少5个节点 三种节点 leader、follower、candidate 每一次选举都是一次term，选举失败也算一次。 每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower RPC 有两种vote、 append 、 （retry） 选主 心跳 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）
election timeout，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时
选举，每个节点投票给第一个找自己竞选的，参选者投自己。
收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。
如果超时，增加term，重新竞选。
防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout
日志复制 先群发 appendRpc。超过半数确认，然后commit。append中下发commited index 超时无响应，重发
日志信息保存term
append 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受 主节点被拒绝后，会减小index
当主节点出错时，新任leader强制以自己的log为准 主节点保存所有从的 nextIndex
Safety 之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。
这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。 并且精细了commit的规则 最后，给出了证明
5.4.1 election restriction 有主节点的共识算法，主节点必须存储所有已提交entries。
Raft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他"><meta property="og:type" content="article"><meta property="og:url" content="https://homily707.github.io/db/6.824-lab2-paper/"><meta property="og:image" content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="db"><meta property="article:published_time" content="2022-05-02T13:08:10+08:00"><meta property="article:modified_time" content="2022-05-02T13:08:10+08:00"><meta property="og:site_name" content="mysite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="6.824 Lab2 Paper"><meta name=twitter:description content="replicated state machines 多个状态机保持相同的状态
实现，通过日志，按顺序保存command。先复制，再执行
非拜占庭问题下正常工作 多数节点可用时整体可用 paxos 缺点 难以理解、不好实现
设计 分解、减少状态
algorithm basics 最少5个节点 三种节点 leader、follower、candidate 每一次选举都是一次term，选举失败也算一次。 每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower RPC 有两种vote、 append 、 （retry） 选主 心跳 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）
election timeout，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时
选举，每个节点投票给第一个找自己竞选的，参选者投自己。
收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。
如果超时，增加term，重新竞选。
防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout
日志复制 先群发 appendRpc。超过半数确认，然后commit。append中下发commited index 超时无响应，重发
日志信息保存term
append 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受 主节点被拒绝后，会减小index
当主节点出错时，新任leader强制以自己的log为准 主节点保存所有从的 nextIndex
Safety 之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。
这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。 并且精细了commit的规则 最后，给出了证明
5.4.1 election restriction 有主节点的共识算法，主节点必须存储所有已提交entries。
Raft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Dbs","item":"https://homily707.github.io/db/"},{"@type":"ListItem","position":2,"name":"6.824 Lab2 Paper","item":"https://homily707.github.io/db/6.824-lab2-paper/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"6.824 Lab2 Paper","name":"6.824 Lab2 Paper","description":"replicated state machines 多个状态机保持相同的状态\n实现，通过日志，按顺序保存command。先复制，再执行\n非拜占庭问题下正常工作 多数节点可用时整体可用 paxos 缺点 难以理解、不好实现\n设计 分解、减少状态\nalgorithm basics 最少5个节点 三种节点 leader、follower、candidate 每一次选举都是一次term，选举失败也算一次。 每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower RPC 有两种vote、 append 、 （retry） 选主 心跳 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）\nelection timeout，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时\n选举，每个节点投票给第一个找自己竞选的，参选者投自己。\n收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。\n如果超时，增加term，重新竞选。\n防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout\n日志复制 先群发 appendRpc。超过半数确认，然后commit。append中下发commited index 超时无响应，重发\n日志信息保存term\nappend 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受 主节点被拒绝后，会减小index\n当主节点出错时，新任leader强制以自己的log为准 主节点保存所有从的 nextIndex\nSafety 之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。\n这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。 并且精细了commit的规则 最后，给出了证明\n5.4.1 election restriction 有主节点的共识算法，主节点必须存储所有已提交entries。\nRaft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他","keywords":[],"articleBody":"replicated state machines 多个状态机保持相同的状态\n实现，通过日志，按顺序保存command。先复制，再执行\n非拜占庭问题下正常工作 多数节点可用时整体可用 paxos 缺点 难以理解、不好实现\n设计 分解、减少状态\nalgorithm basics 最少5个节点 三种节点 leader、follower、candidate 每一次选举都是一次term，选举失败也算一次。 每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower RPC 有两种vote、 append 、 （retry） 选主 心跳 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）\nelection timeout，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时\n选举，每个节点投票给第一个找自己竞选的，参选者投自己。\n收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。\n如果超时，增加term，重新竞选。\n防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout\n日志复制 先群发 appendRpc。超过半数确认，然后commit。append中下发commited index 超时无响应，重发\n日志信息保存term\nappend 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受 主节点被拒绝后，会减小index\n当主节点出错时，新任leader强制以自己的log为准 主节点保存所有从的 nextIndex\nSafety 之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。\n这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。 并且精细了commit的规则 最后，给出了证明\n5.4.1 election restriction 有主节点的共识算法，主节点必须存储所有已提交entries。\nRaft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他\n在选举过程中，如果某个选举人的commit比别的落后，不可以当主\n日志比较。term高者最新，term相同，index高者最新\n5.4.2 commit from pervious term 新皇上位时，可能覆盖已经commit的entry。\n不是当前任期的日志，不通过数副本方式提交。如果拿到当前任期的commit日志，改日志之前的，全部提交\n","wordCount":"79","inLanguage":"en","image":"https://homily707.github.io/%3Cimage%20path/url%3E","datePublished":"2022-05-02T13:08:10+08:00","dateModified":"2022-05-02T13:08:10+08:00","author":{"@type":"Person","name":"homily"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://homily707.github.io/db/6.824-lab2-paper/"},"publisher":{"@type":"Organization","name":"斯是陋室","logo":{"@type":"ImageObject","url":"https://homily707.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://homily707.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://homily707.github.io/algo/ title=算法><span>算法</span></a></li><li><a href=https://homily707.github.io/db/ title=数据库><span>数据库</span></a></li><li><a href=https://homily707.github.io/k8s/ title=k8s><span>k8s</span></a></li><li><a href=https://homily707.github.io/go/ title=go><span>go</span></a></li><li><a href=https://homily707.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://homily707.github.io/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://homily707.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://homily707.github.io/db/>Dbs</a></div><h1 class=post-title>6.824 Lab2 Paper</h1><div class=post-meta><span title='2022-05-02 13:08:10 +0800 CST'>May 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;79 words&nbsp;·&nbsp;homily&nbsp;|&nbsp;<a href=https://github.com/homily707/homily707.github.io/issues rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#设计>设计</a></li></ul><ul><li><a href=#basics>basics</a></li><li><a href=#选主>选主</a></li><li><a href=#日志复制>日志复制</a></li><li><a href=#safety>Safety</a><ul><li><a href=#541-election-restriction>5.4.1 election restriction</a></li><li><a href=#542-commit-from-pervious-term>5.4.2 commit from pervious term</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=replicated-state-machines>replicated state machines<a hidden class=anchor aria-hidden=true href=#replicated-state-machines>#</a></h1><p>多个状态机保持相同的状态</p><p>实现，通过日志，按顺序保存command。先复制，再执行</p><ul><li>非拜占庭问题下正常工作</li><li>多数节点可用时整体可用</li><li></li></ul><h1 id=paxos-缺点>paxos 缺点<a hidden class=anchor aria-hidden=true href=#paxos-缺点>#</a></h1><p>难以理解、不好实现</p><h2 id=设计>设计<a hidden class=anchor aria-hidden=true href=#设计>#</a></h2><p>分解、减少状态</p><h1 id=algorithm>algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h1><h2 id=basics>basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h2><ul><li>最少5个节点</li><li>三种节点 leader、follower、candidate</li><li>每一次选举都是一次term，选举失败也算一次。
每个节点存储当前 term，并在每次交流中带上，如果自己过时了（乃不知有汉，无论魏晋），则跟上最新的。leader和candidater 如果发现过时，退为follower</li><li>RPC 有两种vote、 append 、 （retry）</li></ul><h2 id=选主>选主<a hidden class=anchor aria-hidden=true href=#选主>#</a></h2><p><strong>心跳</strong> 开始都是follower。leader会定期发送心跳（没有log的 appendRpc）</p><p><strong>election timeout</strong>，follower长期没收到心跳，开始竞选。增加 term，切为 candidate，开始循环给所有人发送 voteRpc。会有3种结果 自己选上、别人选上、超时</p><p>选举，每个节点投票给第一个找自己竞选的，参选者投自己。</p><p>收到超过半数的投票，自己上任，给别人发心跳。如果收到竞选term的leader指令，代表自己失败。</p><p>如果超时，增加term，重新竞选。</p><p>防止多人参选，随机election timeout。candidate需要每次选举前，更新随机timeout</p><h2 id=日志复制>日志复制<a hidden class=anchor aria-hidden=true href=#日志复制>#</a></h2><p>先群发 appendRpc。超过半数确认，然后commit。append中下发commited index
超时无响应，重发</p><p>日志信息保存term</p><p>append 带上 上一次的entry，follower没找到这个的话，说明有漏，就不接受
主节点被拒绝后，会减小index</p><p>当主节点出错时，新任leader强制以自己的log为准
主节点保存所有从的 nextIndex</p><h2 id=safety>Safety<a hidden class=anchor aria-hidden=true href=#safety>#</a></h2><p>之前两节并不能保证各节点 exec same command in same order。比如一个落后很多的节点，timeout后竞选成为主节点然后执行后续命令会导致其他节点出错。</p><p>这一节添加了选为主节点的限制。保证每个任期的leader都持有所有已提交的命令。
并且精细了commit的规则
最后，给出了证明</p><h3 id=541-election-restriction>5.4.1 election restriction<a hidden class=anchor aria-hidden=true href=#541-election-restriction>#</a></h3><p>有主节点的共识算法，主节点必须存储所有已提交entries。</p><p>Raft在不向主节点传递日志的情况下实现这一点。log流向只会从主节点发往其他</p><p>在选举过程中，如果某个选举人的commit比别的落后，不可以当主</p><p>日志比较。term高者最新，term相同，index高者最新</p><h3 id=542-commit-from-pervious-term>5.4.2 commit from pervious term<a hidden class=anchor aria-hidden=true href=#542-commit-from-pervious-term>#</a></h3><p>新皇上位时，可能覆盖已经commit的entry。</p><p>不是当前任期的日志，不通过数副本方式提交。如果拿到当前任期的commit日志，改日志之前的，全部提交</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://utteranc.es/client.js repo=homily707/homily707.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://homily707.github.io/>斯是陋室</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>
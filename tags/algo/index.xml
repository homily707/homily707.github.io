<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algo on 斯是陋室</title>
    <link>https://homily707.github.io/tags/algo/</link>
    <description>Recent content in algo on 斯是陋室</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 18 May 2020 11:19:16 +0800</lastBuildDate><atom:link href="https://homily707.github.io/tags/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>树状数组</title>
      <link>https://homily707.github.io/posts/algo/binaryindextree/</link>
      <pubDate>Mon, 18 May 2020 11:19:16 +0800</pubDate>
      
      <guid>https://homily707.github.io/posts/algo/binaryindextree/</guid>
      <description>原理理解 lowbit 就是数字的最低位 11000 -》 1000
在树状数组中，我们用lowbit表示这个下标的sum，包含了几个数。比如 11010 的 lowbit 为 10，即他管辖了 （11000，11010] 这两个数的和，左开右闭。所以当我们要求【0，x】的和的时候，就是求[0，x-lowbit(x)]+（x-lowbit(x),x] ，后者我们已经存储好了，前者通过迭代的方式求出。因为是左开右闭，我们实际只能求到（0,x]，所以我们要能额外添加一个index为0的，值也为0的值。所以在实现的时候，真正的数字是从下标1开始的。
一个数加上自己lowbit 11010 + 10 = 11100， 实现的就是最低位的进位，而这个进位所得到的数，一定是管辖自己的数。
实现要点 sum数组的下标和原始数组的下标存在加1的关系 lowbit 用 x&amp;amp;-x实现 show me the code type BinaryIndexTree struct { Data []int SumSlice []int Len int } func (bit *BinaryIndexTree) Init(array []int) { bit.Len = len(array) bit.Data = array bit.SumSlice = make([]int, bit.Len+1) for i, num := range array { bit.addInSum(i, num) } } func (bit *BinaryIndexTree) Add(index int, delta int) { bit.</description>
    </item>
    
  </channel>
</rss>

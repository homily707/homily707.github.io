<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Client Go | 斯是陋室</title><meta name=keywords content="go,k8s"><meta name=description content="work queue Queue
queue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中 dirty set // 标记所有需要被处理的元素 processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里 DelayingQueue 多了一个AddAfter，每次add加入堆中，每次拿出最早的
RateLimitingQueue。限速队列
Delta FIFO 接口queue
接口store
items map[string]Delta
Delta. 五种type added updated deleted replaced sync . 带一个 interface{}
Pop方法：会阻塞。传入的是一个函数，如果执行失败重新入队
Indexer type Indexer interface { Store Index(indexName string, obj interface{}) ([]interface{}, error) // 根据索引名和给定的对象返回符合条件的所有对象 IndexKeys(indexName, indexedValue string) ([]string, error) // 根据索引名和索引值返回符合条件的所有对象的 key ListIndexFuncValues(indexName string) []string // 列出索引函数计算出来的所有索引值 ByIndex(indexName, indexedValue string) ([]interface{}, error) // 根据索引名和索引值返回符合条件的所有对象 GetIndexers() Indexers // 获取所有的 Indexers，对应 map[string]IndexFunc 类型 AddIndexers(newIndexers Indexers) error // 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索 } type Store interface { Add(obj interface{}) error Update(obj interface{}) error Delete(obj interface{}) error List() []interface{} ListKeys() []string Get(obj interface{}) (item interface{}, exists bool, err error) GetByKey(key string) (item interface{}, exists bool, err error) Replace([]interface{}, string) error Resync() error } // 默认实现类 type cache struct { cacheStorage ThreadSafeStore keyFunc KeyFunc } keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object"><meta name=author content="homily"><link rel=canonical href=https://homily707.github.io/posts/k8s/client-go/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://homily707.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://homily707.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://homily707.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://homily707.github.io/apple-touch-icon.png><link rel=mask-icon href=https://homily707.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Client Go"><meta property="og:description" content="work queue Queue
queue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中 dirty set // 标记所有需要被处理的元素 processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里 DelayingQueue 多了一个AddAfter，每次add加入堆中，每次拿出最早的
RateLimitingQueue。限速队列
Delta FIFO 接口queue
接口store
items map[string]Delta
Delta. 五种type added updated deleted replaced sync . 带一个 interface{}
Pop方法：会阻塞。传入的是一个函数，如果执行失败重新入队
Indexer type Indexer interface { Store Index(indexName string, obj interface{}) ([]interface{}, error) // 根据索引名和给定的对象返回符合条件的所有对象 IndexKeys(indexName, indexedValue string) ([]string, error) // 根据索引名和索引值返回符合条件的所有对象的 key ListIndexFuncValues(indexName string) []string // 列出索引函数计算出来的所有索引值 ByIndex(indexName, indexedValue string) ([]interface{}, error) // 根据索引名和索引值返回符合条件的所有对象 GetIndexers() Indexers // 获取所有的 Indexers，对应 map[string]IndexFunc 类型 AddIndexers(newIndexers Indexers) error // 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索 } type Store interface { Add(obj interface{}) error Update(obj interface{}) error Delete(obj interface{}) error List() []interface{} ListKeys() []string Get(obj interface{}) (item interface{}, exists bool, err error) GetByKey(key string) (item interface{}, exists bool, err error) Replace([]interface{}, string) error Resync() error } // 默认实现类 type cache struct { cacheStorage ThreadSafeStore keyFunc KeyFunc } keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object"><meta property="og:type" content="article"><meta property="og:url" content="https://homily707.github.io/posts/k8s/client-go/"><meta property="og:image" content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-10T22:39:11+08:00"><meta property="article:modified_time" content="2022-06-10T22:39:11+08:00"><meta property="og:site_name" content="mysite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Client Go"><meta name=twitter:description content="work queue Queue
queue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中 dirty set // 标记所有需要被处理的元素 processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里 DelayingQueue 多了一个AddAfter，每次add加入堆中，每次拿出最早的
RateLimitingQueue。限速队列
Delta FIFO 接口queue
接口store
items map[string]Delta
Delta. 五种type added updated deleted replaced sync . 带一个 interface{}
Pop方法：会阻塞。传入的是一个函数，如果执行失败重新入队
Indexer type Indexer interface { Store Index(indexName string, obj interface{}) ([]interface{}, error) // 根据索引名和给定的对象返回符合条件的所有对象 IndexKeys(indexName, indexedValue string) ([]string, error) // 根据索引名和索引值返回符合条件的所有对象的 key ListIndexFuncValues(indexName string) []string // 列出索引函数计算出来的所有索引值 ByIndex(indexName, indexedValue string) ([]interface{}, error) // 根据索引名和索引值返回符合条件的所有对象 GetIndexers() Indexers // 获取所有的 Indexers，对应 map[string]IndexFunc 类型 AddIndexers(newIndexers Indexers) error // 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索 } type Store interface { Add(obj interface{}) error Update(obj interface{}) error Delete(obj interface{}) error List() []interface{} ListKeys() []string Get(obj interface{}) (item interface{}, exists bool, err error) GetByKey(key string) (item interface{}, exists bool, err error) Replace([]interface{}, string) error Resync() error } // 默认实现类 type cache struct { cacheStorage ThreadSafeStore keyFunc KeyFunc } keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://homily707.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Client Go","item":"https://homily707.github.io/posts/k8s/client-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Client Go","name":"Client Go","description":"work queue Queue\nqueue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中 dirty set // 标记所有需要被处理的元素 processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里 DelayingQueue 多了一个AddAfter，每次add加入堆中，每次拿出最早的\nRateLimitingQueue。限速队列\nDelta FIFO 接口queue\n接口store\nitems map[string]Delta\nDelta. 五种type added updated deleted replaced sync . 带一个 interface{}\nPop方法：会阻塞。传入的是一个函数，如果执行失败重新入队\nIndexer type Indexer interface { Store Index(indexName string, obj interface{}) ([]interface{}, error) // 根据索引名和给定的对象返回符合条件的所有对象 IndexKeys(indexName, indexedValue string) ([]string, error) // 根据索引名和索引值返回符合条件的所有对象的 key ListIndexFuncValues(indexName string) []string // 列出索引函数计算出来的所有索引值 ByIndex(indexName, indexedValue string) ([]interface{}, error) // 根据索引名和索引值返回符合条件的所有对象 GetIndexers() Indexers // 获取所有的 Indexers，对应 map[string]IndexFunc 类型 AddIndexers(newIndexers Indexers) error // 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索 } type Store interface { Add(obj interface{}) error Update(obj interface{}) error Delete(obj interface{}) error List() []interface{} ListKeys() []string Get(obj interface{}) (item interface{}, exists bool, err error) GetByKey(key string) (item interface{}, exists bool, err error) Replace([]interface{}, string) error Resync() error } // 默认实现类 type cache struct { cacheStorage ThreadSafeStore keyFunc KeyFunc } keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object","keywords":["go","k8s"],"articleBody":" work queue Queue\nqueue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中 dirty set // 标记所有需要被处理的元素 processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里 DelayingQueue 多了一个AddAfter，每次add加入堆中，每次拿出最早的\nRateLimitingQueue。限速队列\nDelta FIFO 接口queue\n接口store\nitems map[string]Delta\nDelta. 五种type added updated deleted replaced sync . 带一个 interface{}\nPop方法：会阻塞。传入的是一个函数，如果执行失败重新入队\nIndexer type Indexer interface { Store Index(indexName string, obj interface{}) ([]interface{}, error) // 根据索引名和给定的对象返回符合条件的所有对象 IndexKeys(indexName, indexedValue string) ([]string, error) // 根据索引名和索引值返回符合条件的所有对象的 key ListIndexFuncValues(indexName string) []string // 列出索引函数计算出来的所有索引值 ByIndex(indexName, indexedValue string) ([]interface{}, error) // 根据索引名和索引值返回符合条件的所有对象 GetIndexers() Indexers // 获取所有的 Indexers，对应 map[string]IndexFunc 类型 AddIndexers(newIndexers Indexers) error // 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索 } type Store interface { Add(obj interface{}) error Update(obj interface{}) error Delete(obj interface{}) error List() []interface{} ListKeys() []string Get(obj interface{}) (item interface{}, exists bool, err error) GetByKey(key string) (item interface{}, exists bool, err error) Replace([]interface{}, string) error Resync() error } // 默认实现类 type cache struct { cacheStorage ThreadSafeStore keyFunc KeyFunc } keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object\nstore的实现 type threadSafeMap struct { lock sync.RWMutex items map[string]interface{} // indexers maps a name to an IndexFunc indexers Indexers // indices maps a name to an Index indices Indices } type Index map[string]sets.String type Indexers map[string]IndexFunc type Indices map[string]Index type IndexFunc func(obj interface{}) ([]string, error) 举例：\nfunc testUsersIndexFunc(obj interface{}) ([]string, error) { pod := obj.(*v1.Pod) usersString := pod.Annotations[\"users\"] return strings.Split(usersString, \",\"), nil } func TestMultiIndexKeys(t *testing.T) { index := NewIndexer(MetaNamespaceKeyFunc, Indexers{\"byUser\": testUsersIndexFunc}) pod1 := \u0026v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: \"one\", Annotations: map[string]string{\"users\": \"ernie,bert\"}}} pod2 := \u0026v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: \"two\", Annotations: map[string]string{\"users\": \"bert,oscar\"}}} pod3 := \u0026v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: \"tre\", Annotations: map[string]string{\"users\": \"ernie,elmo\"}}} } item 存储的就是3个pod， indexer 存储了一个func，这个func会将pod的users split成多个并返回 indices 存储了一个 index，其中ernie 对应了2个key，这个key用于item查询\n看到这里就会恍然大悟，这其实就是一个倒排索引。当func多了以后，就能实现非常强悍的功能了。\nListWatcher 经典的 接口组合\nlist 和 watch 直接调用 restClient 这里额外需要一个Getter 来返回 rest request。 然后使用闭包函数的形式，把getter传给restClient getter的实现类 在 rest/client.go 中，经典的builder模式\ntype Lister interface { List(options metav1.ListOptions) (runtime.Object, error) } type Watcher interface { Watch(options metav1.ListOptions) (watch.Interface, error) } // ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource. type ListerWatcher interface { Lister Watcher } type Getter interface { Get() *restclient.Request } func NewListWatchFromClient(c Getter, resource string, namespace string, fieldSelector fields.Selector) *ListWatch { optionsModifier := func(options *metav1.ListOptions) { options.FieldSelector = fieldSelector.String() } return NewFilteredListWatchFromClient(c, resource, namespace, optionsModifier) } Reflector 健壮性保证\nlist ，传一个sync 到 DeltaFIFO\nwatch，watchHandler 处理后 传入 DeltaFIFO\ninformer type Controller interface { // Run does two things. One is to construct and run a Reflector // to pump objects/notifications from the Config's ListerWatcher // to the Config's Queue and possibly invoke the occasional Resync // on that Queue. The other is to repeatedly Pop from the Queue // and process with the Config's ProcessFunc. Both of these // continue until `stopCh` is closed. Run(stopCh \u003c-chan struct{}) HasSynced() bool LastSyncResourceVersion() string } type controller struct { config Config reflector *Reflector reflectorMutex sync.RWMutex clock clock.Clock } type Config struct { // The queue for your objects - has to be a DeltaFIFO due to // assumptions in the implementation. Your Process() function // should accept the output of this Queue's Pop() method. Queue // Something that can list and watch your objects. ListerWatcher // Something that can process a popped Deltas. Process ProcessFunc ObjectType runtime.Object FullResyncPeriod time.Duration RetryOnError bool WatchErrorHandler WatchErrorHandler WatchListPageSize int64 } type ResourceEventHandler interface { OnAdd(obj interface{}) OnUpdate(oldObj, newObj interface{}) OnDelete(obj interface{}) } 真正的处理逻辑 就是 config里的Process\nSharedIndexInformer type sharedIndexInformer struct { indexer Indexer controller Controller processor *sharedProcessor cacheMutationDetector MutationDetector listerWatcher ListerWatcher // 表示当前 Informer 期望关注的类型，主要是 GVK 信息 objectType runtime.Object // reflector 的 resync 计时器计时间隔，通知所有的 listener 执行 resync resyncCheckPeriod time.Duration defaultEventHandlerResyncPeriod time.Duration clock clock.Clock started, stopped bool startedLock sync.Mutex blockDeltas sync.Mutex watchErrorHandler WatchErrorHandler } type sharedProcessor struct { listenersStarted bool listenersLock sync.RWMutex listeners []*processorListener syncingListeners []*processorListener clock clock.Clock wg wait.Group } type processorListener struct { nextCh chan interface{} addCh chan interface{} // 核心属性 handler ResourceEventHandler pendingNotifications buffer.RingGrowing requestedResyncPeriod time.Duration resyncPeriod time.Duration nextResync time.Time resyncLock sync.Mutex } 核心就是对delta的处理\nfunc (s *sharedIndexInformer) HandleDeltas(obj interface{}) error { s.blockDeltas.Lock() defer s.blockDeltas.Unlock() if deltas, ok := obj.(Deltas); ok { // 把自己作为 event handler 传进去 return processDeltas(s, s.indexer, s.transform, deltas) } return errors.New(\"object given as Process argument is not Deltas\") } func processDeltas( // Object which receives event notifications from the given deltas handler ResourceEventHandler, clientState Store, transformer TransformFunc, deltas Deltas, ) ","wordCount":"679","inLanguage":"en","image":"https://homily707.github.io/%3Cimage%20path/url%3E","datePublished":"2022-06-10T22:39:11+08:00","dateModified":"2022-06-10T22:39:11+08:00","author":{"@type":"Person","name":"homily"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://homily707.github.io/posts/k8s/client-go/"},"publisher":{"@type":"Organization","name":"斯是陋室","logo":{"@type":"ImageObject","url":"https://homily707.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://homily707.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://homily707.github.io/tags/algo/ title=算法><span>算法</span></a></li><li><a href=https://homily707.github.io/tags/data/ title=数据库><span>数据库</span></a></li><li><a href=https://homily707.github.io/tags/k8s/ title=k8s><span>k8s</span></a></li><li><a href=https://homily707.github.io/tags/go/ title=go><span>go</span></a></li><li><a href=https://homily707.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://homily707.github.io/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://homily707.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://homily707.github.io/posts/>Posts</a></div><h1 class=post-title>Client Go</h1><div class=post-meta><span title='2022-06-10 22:39:11 +0800 CST'>June 10, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;679 words&nbsp;·&nbsp;homily&nbsp;|&nbsp;<a href=https://github.com/homily707/homily707.github.io/issues rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#work-queue>work queue</a></li><li><a href=#delta-fifo>Delta FIFO</a></li><li><a href=#indexer>Indexer</a><ul><li><a href=#store的实现>store的实现</a></li></ul></li><li><a href=#listwatcher>ListWatcher</a></li><li><a href=#reflector>Reflector</a></li><li><a href=#informer>informer</a><ul><li><a href=#sharedindexinformer><strong>SharedIndexInformer</strong></a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><img loading=lazy src=https://secure2.wostatic.cn/static/d7KMR8ZuATRzDhQW48ziha/image.png alt></p><h2 id=work-queue>work queue<a hidden class=anchor aria-hidden=true href=#work-queue>#</a></h2><p>Queue</p><ul><li>queue []t // 定义元素的处理顺序，里面所有元素都应该在 dirty set 中有，而不能出现在 processing set 中</li><li>dirty set // 标记所有需要被处理的元素</li><li>processing set // 当前正在被处理的元素，当处理完后需要检查该元素是否在 dirty set 中，如果有则添加到 queue 里</li></ul><p>DelayingQueue
多了一个AddAfter，每次add加入堆中，每次拿出最早的</p><p>RateLimitingQueue。限速队列</p><h2 id=delta-fifo>Delta FIFO<a hidden class=anchor aria-hidden=true href=#delta-fifo>#</a></h2><p>接口queue</p><p>接口store</p><p>items map[string]Delta</p><p>Delta. 五种type added updated deleted replaced sync . 带一个 interface{}</p><p>Pop方法：会阻塞。传入的是一个函数，如果执行失败重新入队</p><h2 id=indexer>Indexer<a hidden class=anchor aria-hidden=true href=#indexer>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Indexer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>Store</span>
</span></span><span class=line><span class=cl>   <span class=nf>Index</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=c1>// 根据索引名和给定的对象返回符合条件的所有对象
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>IndexKeys</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexedValue</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>     <span class=c1>// 根据索引名和索引值返回符合条件的所有对象的 key
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>ListIndexFuncValues</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span>                  <span class=c1>// 列出索引函数计算出来的所有索引值
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>ByIndex</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexedValue</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>  <span class=c1>// 根据索引名和索引值返回符合条件的所有对象
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>GetIndexers</span><span class=p>()</span> <span class=nx>Indexers</span>                     <span class=c1>// 获取所有的 Indexers，对应 map[string]IndexFunc 类型
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>AddIndexers</span><span class=p>(</span><span class=nx>newIndexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=kt>error</span>    <span class=c1>// 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Store</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>Add</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=nf>Update</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=nf>Delete</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=nf>List</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>  <span class=nf>Get</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>Replace</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>  <span class=nf>Resync</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 默认实现类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>cache</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>cacheStorage</span> <span class=nx>ThreadSafeStore</span>
</span></span><span class=line><span class=cl>   <span class=nx>keyFunc</span> <span class=nx>KeyFunc</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>keyfunc 计算 object的key，然后用ThreadSafeStore存储key：object</p><h3 id=store的实现>store的实现<a hidden class=anchor aria-hidden=true href=#store的实现>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>threadSafeMap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>lock</span>  <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>items</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>   <span class=c1>// indexers maps a name to an IndexFunc
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>indexers</span> <span class=nx>Indexers</span>
</span></span><span class=line><span class=cl>   <span class=c1>// indices maps a name to an Index
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>indices</span> <span class=nx>Indices</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Indexers</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>IndexFunc</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Indices</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Index</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IndexFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>举例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testUsersIndexFunc</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>pod</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>usersString</span> <span class=o>:=</span> <span class=nx>pod</span><span class=p>.</span><span class=nx>Annotations</span><span class=p>[</span><span class=s>&#34;users&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>usersString</span><span class=p>,</span> <span class=s>&#34;,&#34;</span><span class=p>),</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMultiIndexKeys</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>index</span> <span class=o>:=</span> <span class=nf>NewIndexer</span><span class=p>(</span><span class=nx>MetaNamespaceKeyFunc</span><span class=p>,</span> <span class=nx>Indexers</span><span class=p>{</span><span class=s>&#34;byUser&#34;</span><span class=p>:</span> <span class=nx>testUsersIndexFunc</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>pod1</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>{</span><span class=nx>ObjectMeta</span><span class=p>:</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;one&#34;</span><span class=p>,</span> <span class=nx>Annotations</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;users&#34;</span><span class=p>:</span> <span class=s>&#34;ernie,bert&#34;</span><span class=p>}}}</span>
</span></span><span class=line><span class=cl>  <span class=nx>pod2</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>{</span><span class=nx>ObjectMeta</span><span class=p>:</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;two&#34;</span><span class=p>,</span> <span class=nx>Annotations</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;users&#34;</span><span class=p>:</span> <span class=s>&#34;bert,oscar&#34;</span><span class=p>}}}</span>
</span></span><span class=line><span class=cl>  <span class=nx>pod3</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>{</span><span class=nx>ObjectMeta</span><span class=p>:</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;tre&#34;</span><span class=p>,</span> <span class=nx>Annotations</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;users&#34;</span><span class=p>:</span> <span class=s>&#34;ernie,elmo&#34;</span><span class=p>}}}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>item 存储的就是3个pod，
indexer 存储了一个func，这个func会将pod的users split成多个并返回
indices 存储了一个 index，其中ernie 对应了2个key，这个key用于item查询</p><p><img loading=lazy src=https://secure2.wostatic.cn/static/3U2iyuejLkobvwUoZ58XQf/image.png alt></p><p><img loading=lazy src=https://secure2.wostatic.cn/static/ii5SYxWqrLP9or7GxBCzJS/image.png alt></p><p><img loading=lazy src=https://secure2.wostatic.cn/static/2oXqsf48KitnB1GgCMVqJG/image.png alt></p><p>看到这里就会恍然大悟，这其实就是一个倒排索引。当func多了以后，就能实现非常强悍的功能了。</p><h2 id=listwatcher>ListWatcher<a hidden class=anchor aria-hidden=true href=#listwatcher>#</a></h2><p>经典的 接口组合</p><p>list 和 watch 直接调用 restClient
这里额外需要一个Getter 来返回 rest request。
然后使用闭包函数的形式，把getter传给restClient
getter的实现类 在 rest/client.go 中，经典的builder模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Lister</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>List</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Watcher</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Watch</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>watch</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ListerWatcher</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Lister</span>
</span></span><span class=line><span class=cl>  <span class=nx>Watcher</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Getter</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Get</span><span class=p>()</span> <span class=o>*</span><span class=nx>restclient</span><span class=p>.</span><span class=nx>Request</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewListWatchFromClient</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Getter</span><span class=p>,</span> <span class=nx>resource</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>namespace</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fieldSelector</span> <span class=nx>fields</span><span class=p>.</span><span class=nx>Selector</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListWatch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>optionsModifier</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>options</span> <span class=o>*</span><span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>options</span><span class=p>.</span><span class=nx>FieldSelector</span> <span class=p>=</span> <span class=nx>fieldSelector</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>NewFilteredListWatchFromClient</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>namespace</span><span class=p>,</span> <span class=nx>optionsModifier</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=reflector>Reflector<a hidden class=anchor aria-hidden=true href=#reflector>#</a></h2><p>健壮性保证</p><p>list ，传一个sync 到 DeltaFIFO</p><p>watch，watchHandler 处理后 传入 DeltaFIFO</p><h2 id=informer>informer<a hidden class=anchor aria-hidden=true href=#informer>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Controller</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Run does two things.  One is to construct and run a Reflector
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// to pump objects/notifications from the Config&#39;s ListerWatcher
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// to the Config&#39;s Queue and possibly invoke the occasional Resync
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// on that Queue.  The other is to repeatedly Pop from the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// and process with the Config&#39;s ProcessFunc.  Both of these
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// continue until `stopCh` is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>  <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  <span class=nf>LastSyncResourceVersion</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>controller</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>config</span>         <span class=nx>Config</span>
</span></span><span class=line><span class=cl>  <span class=nx>reflector</span>      <span class=o>*</span><span class=nx>Reflector</span>
</span></span><span class=line><span class=cl>  <span class=nx>reflectorMutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>  <span class=nx>clock</span>          <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Config</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// The queue for your objects - has to be a DeltaFIFO due to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// assumptions in the implementation. Your Process() function
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// should accept the output of this Queue&#39;s Pop() method.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>Queue</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Something that can list and watch your objects.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>ListerWatcher</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Something that can process a popped Deltas.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>Process</span> <span class=nx>ProcessFunc</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>ObjectType</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span>
</span></span><span class=line><span class=cl>  <span class=nx>FullResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>  <span class=nx>RetryOnError</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  <span class=nx>WatchErrorHandler</span> <span class=nx>WatchErrorHandler</span>
</span></span><span class=line><span class=cl>  <span class=nx>WatchListPageSize</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ResourceEventHandler</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>OnAdd</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>  <span class=nf>OnUpdate</span><span class=p>(</span><span class=nx>oldObj</span><span class=p>,</span> <span class=nx>newObj</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>  <span class=nf>OnDelete</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>真正的处理逻辑 就是 config里的Process</p><h3 id=sharedindexinformer><strong>SharedIndexInformer</strong><a hidden class=anchor aria-hidden=true href=#sharedindexinformer>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>sharedIndexInformer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>indexer</span>    <span class=nx>Indexer</span>
</span></span><span class=line><span class=cl>   <span class=nx>controller</span> <span class=nx>Controller</span>
</span></span><span class=line><span class=cl>   <span class=nx>processor</span>             <span class=o>*</span><span class=nx>sharedProcessor</span>
</span></span><span class=line><span class=cl>   <span class=nx>cacheMutationDetector</span> <span class=nx>MutationDetector</span>
</span></span><span class=line><span class=cl>   <span class=nx>listerWatcher</span> <span class=nx>ListerWatcher</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 表示当前 Informer 期望关注的类型，主要是 GVK 信息
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>objectType</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span>
</span></span><span class=line><span class=cl>   <span class=c1>// reflector 的 resync 计时器计时间隔，通知所有的 listener 执行 resync
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>resyncCheckPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>   <span class=nx>defaultEventHandlerResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>   <span class=nx>clock</span> <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>
</span></span><span class=line><span class=cl>   <span class=nx>started</span><span class=p>,</span> <span class=nx>stopped</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>   <span class=nx>startedLock</span>      <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>blockDeltas</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>watchErrorHandler</span> <span class=nx>WatchErrorHandler</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>sharedProcessor</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>listenersStarted</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>   <span class=nx>listenersLock</span>    <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>listeners</span>        <span class=p>[]</span><span class=o>*</span><span class=nx>processorListener</span>
</span></span><span class=line><span class=cl>   <span class=nx>syncingListeners</span> <span class=p>[]</span><span class=o>*</span><span class=nx>processorListener</span>
</span></span><span class=line><span class=cl>   <span class=nx>clock</span>            <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>
</span></span><span class=line><span class=cl>   <span class=nx>wg</span>               <span class=nx>wait</span><span class=p>.</span><span class=nx>Group</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>processorListener</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>nextCh</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>   <span class=nx>addCh</span>  <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 核心属性
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>handler</span> <span class=nx>ResourceEventHandler</span>
</span></span><span class=line><span class=cl>   <span class=nx>pendingNotifications</span> <span class=nx>buffer</span><span class=p>.</span><span class=nx>RingGrowing</span>
</span></span><span class=line><span class=cl>   <span class=nx>requestedResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>   <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>   <span class=nx>nextResync</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>   <span class=nx>resyncLock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>核心就是对delta的处理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>sharedIndexInformer</span><span class=p>)</span> <span class=nf>HandleDeltas</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>deltas</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=nx>Deltas</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 把自己作为 event handler 传进去
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>processDeltas</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>transform</span><span class=p>,</span> <span class=nx>deltas</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;object given as Process argument is not Deltas&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>processDeltas</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Object which receives event notifications from the given deltas
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>handler</span> <span class=nx>ResourceEventHandler</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>clientState</span> <span class=nx>Store</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>transformer</span> <span class=nx>TransformFunc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>deltas</span> <span class=nx>Deltas</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> 
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://homily707.github.io/tags/go/>go</a></li><li><a href=https://homily707.github.io/tags/k8s/>k8s</a></li></ul><nav class=paginav><a class=next href=https://homily707.github.io/posts/db/6.824-lab2-coding/><span class=title>Next »</span><br><span>6.824 Lab2 Coding</span></a></nav></footer><script src=https://utteranc.es/client.js repo=homily707/homily707.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://homily707.github.io/>斯是陋室</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式数据库笔记 | 斯是陋室</title><meta name=keywords content="data"><meta name=description content="存储的设计 事务模型 查询引擎 复制 基础篇 外部视角 写多读少、低延时、高并发
海量并发（分布式和单体的区别）
高可靠
rto 恢复时间 rpo 恢复点
海量存储
内部视角 客户端组件 + 单体 sharding jdbc 中间件 + 单体。 MyCat 应用层重构 + 单体 数据一致性 状态一致性
强一致：mysql 全同步复制 弱一致：eventually consistency 操作一致性
写后读 写入成功，异步复制，保证写入者能读到 单调读 读过的数据，不会消失。将用户和副本建立映射关系。 前缀 保证事件复制的因果关系 线性一致性 Linearizability 所有操作可以比较先后顺序。通过全局时钟建立全序关系。 线性一致性是描述历史记录的，而不是描述系统的。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。 因果一致 逻辑时钟，建立不那么准确的 全序关系 事务一致性 ACID
一致性：整体目标
持久性：数据丢失、故障容错。write ahead log， 多副本
隔离性 异常现象 幻读： T1 查询两次， T2插入。T1第2次读结果集增大
不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致
脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致
隔离级别 未提交读： 脏读"><meta name=author content="homily"><link rel=canonical href=https://homily707.github.io/posts/db/distribute-30/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://homily707.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://homily707.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://homily707.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://homily707.github.io/apple-touch-icon.png><link rel=mask-icon href=https://homily707.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="分布式数据库笔记"><meta property="og:description" content="存储的设计 事务模型 查询引擎 复制 基础篇 外部视角 写多读少、低延时、高并发
海量并发（分布式和单体的区别）
高可靠
rto 恢复时间 rpo 恢复点
海量存储
内部视角 客户端组件 + 单体 sharding jdbc 中间件 + 单体。 MyCat 应用层重构 + 单体 数据一致性 状态一致性
强一致：mysql 全同步复制 弱一致：eventually consistency 操作一致性
写后读 写入成功，异步复制，保证写入者能读到 单调读 读过的数据，不会消失。将用户和副本建立映射关系。 前缀 保证事件复制的因果关系 线性一致性 Linearizability 所有操作可以比较先后顺序。通过全局时钟建立全序关系。 线性一致性是描述历史记录的，而不是描述系统的。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。 因果一致 逻辑时钟，建立不那么准确的 全序关系 事务一致性 ACID
一致性：整体目标
持久性：数据丢失、故障容错。write ahead log， 多副本
隔离性 异常现象 幻读： T1 查询两次， T2插入。T1第2次读结果集增大
不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致
脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致
隔离级别 未提交读： 脏读"><meta property="og:type" content="article"><meta property="og:url" content="https://homily707.github.io/posts/db/distribute-30/"><meta property="og:image" content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-03T10:54:06+08:00"><meta property="article:modified_time" content="2022-06-03T10:54:06+08:00"><meta property="og:site_name" content="mysite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://homily707.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="分布式数据库笔记"><meta name=twitter:description content="存储的设计 事务模型 查询引擎 复制 基础篇 外部视角 写多读少、低延时、高并发
海量并发（分布式和单体的区别）
高可靠
rto 恢复时间 rpo 恢复点
海量存储
内部视角 客户端组件 + 单体 sharding jdbc 中间件 + 单体。 MyCat 应用层重构 + 单体 数据一致性 状态一致性
强一致：mysql 全同步复制 弱一致：eventually consistency 操作一致性
写后读 写入成功，异步复制，保证写入者能读到 单调读 读过的数据，不会消失。将用户和副本建立映射关系。 前缀 保证事件复制的因果关系 线性一致性 Linearizability 所有操作可以比较先后顺序。通过全局时钟建立全序关系。 线性一致性是描述历史记录的，而不是描述系统的。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。 因果一致 逻辑时钟，建立不那么准确的 全序关系 事务一致性 ACID
一致性：整体目标
持久性：数据丢失、故障容错。write ahead log， 多副本
隔离性 异常现象 幻读： T1 查询两次， T2插入。T1第2次读结果集增大
不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致
脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致
隔离级别 未提交读： 脏读"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://homily707.github.io/posts/"},{"@type":"ListItem","position":2,"name":"分布式数据库笔记","item":"https://homily707.github.io/posts/db/distribute-30/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"分布式数据库笔记","name":"分布式数据库笔记","description":"存储的设计 事务模型 查询引擎 复制 基础篇 外部视角 写多读少、低延时、高并发\n海量并发（分布式和单体的区别）\n高可靠\nrto 恢复时间 rpo 恢复点\n海量存储\n内部视角 客户端组件 + 单体 sharding jdbc 中间件 + 单体。 MyCat 应用层重构 + 单体 数据一致性 状态一致性\n强一致：mysql 全同步复制 弱一致：eventually consistency 操作一致性\n写后读 写入成功，异步复制，保证写入者能读到 单调读 读过的数据，不会消失。将用户和副本建立映射关系。 前缀 保证事件复制的因果关系 线性一致性 Linearizability 所有操作可以比较先后顺序。通过全局时钟建立全序关系。 线性一致性是描述历史记录的，而不是描述系统的。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。 因果一致 逻辑时钟，建立不那么准确的 全序关系 事务一致性 ACID\n一致性：整体目标\n持久性：数据丢失、故障容错。write ahead log， 多副本\n隔离性 异常现象 幻读： T1 查询两次， T2插入。T1第2次读结果集增大\n不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致\n脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致\n隔离级别 未提交读： 脏读","keywords":["data"],"articleBody":" 存储的设计 事务模型 查询引擎 复制 基础篇 外部视角 写多读少、低延时、高并发\n海量并发（分布式和单体的区别）\n高可靠\nrto 恢复时间 rpo 恢复点\n海量存储\n内部视角 客户端组件 + 单体 sharding jdbc 中间件 + 单体。 MyCat 应用层重构 + 单体 数据一致性 状态一致性\n强一致：mysql 全同步复制 弱一致：eventually consistency 操作一致性\n写后读 写入成功，异步复制，保证写入者能读到 单调读 读过的数据，不会消失。将用户和副本建立映射关系。 前缀 保证事件复制的因果关系 线性一致性 Linearizability 所有操作可以比较先后顺序。通过全局时钟建立全序关系。 线性一致性是描述历史记录的，而不是描述系统的。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。 因果一致 逻辑时钟，建立不那么准确的 全序关系 事务一致性 ACID\n一致性：整体目标\n持久性：数据丢失、故障容错。write ahead log， 多副本\n隔离性 异常现象 幻读： T1 查询两次， T2插入。T1第2次读结果集增大\n不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致\n脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致\n隔离级别 未提交读： 脏读\n已提交读： 不可重复读\n可重复读： 会幻读\n快照隔离： write skew\n可串形化： 事务一个个执行\n架构 客户端通讯 查询处理器 事务管理器 进程管理器 辅助工具 单体数据库\n单体数据库（数据节点） + 协调节点 + 分片信息 + 全局时钟\nnewSql\n计算节点 + 存储节点 + 全局时钟 + 元数据管理\n时钟 spanner true time 物理时间 ，多时间源，多授时点\nTIDB TSO 中心授时 逻辑时钟。\nPD 组成raft组，提供授时服务，使用etcd + 预申请时间窗\n分片 hash 、 一致性hash。（无法处理业务热点，无法范围查询）\nrange 静态\nrange 动态\n动态分裂、合并 通过调度实现存储均衡、压力均衡。减少分布式事务 数据复制 元数据 TIKV 上node多个raft组存储分片信息。PD中心点读取kv心跳，获取当前分片信息。\n复制效率 raft的半数同意会导致效率低，且操作是按顺序apply的\nTIDB优化\nbatch，多个请求一起发送 pipeline，nextIndex parallelly，leader和follower的log并行apply apply，异步执行 分布式事务 原子性 TCC 应用层修改\n2PC 事务管理器，在多个节点上先分别prepare，确认后再commit\n问题：同步阻塞，事务管理器单点故障、commit失败数据不一致。\nPrecolator\n使用mvcc，新增版本。在新版本上加主锁和次锁，次锁指向主锁。\ncommit，删掉主锁即可。次锁记录，lazy 加载，异步删除\n事务延迟 延迟与写操作线性相关\n缓存提交写 隔离性 MVCC。分布式中通过全局事务管理器，维护递增事务id、提供全局快照\n存储方式\nappend-only 存储在表中 delta，独立存储增量 timetravel，独立存储全量 TIDB没有采用快照，读写阻塞\n不确定的时间窗口。\nspanner 写等待 cockroach 读等待\n悲观、乐观 乐观 rcvw 读 算 验证 写\n悲观 vrcw 验证 读 算 写 此处的读是拷贝加改写副本。写是提交\ntidb乐观锁，虽然每一行都悲观的。但是整体事务是没有有效性验证\n悲观，执行sql时，添加锁\n查询 存储过程\n难以调试\n自增主键\n连续递增，事务回滚时会失效 单调递增，并发过大时会失效 尾部热点， HTAP\nOLTP 和 OLAP 之间，需要ETL进行转换，存在时延。\nTiFlash存储分离，flash 作为raft的一个learner。每次查询前找leader实现同步。\n采用delta tree。\nKappa\nkafka加stream计算，快速加工\n计算下推 谓词下推\n分区索引\n全局索引\n查询引擎 火山模型\n向量化模型\n代码生成\nRUM read update memory 三者不能同时优化\nB tree 写放大，实际写比写的操作要多 存储不连续\nLSM tree Tiered\n先写内存，直接返回 内存 flush 进入 sstable sstable compact 合并 读放大，要同时读多个sstable\n写放大，compact操作性能消耗很高\nleveled compact\nL0 可重叠\n整理形成不重叠的L1\n然后部分compact\nWiscKey value单独存储\n","wordCount":"236","inLanguage":"en","image":"https://homily707.github.io/%3Cimage%20path/url%3E","datePublished":"2022-06-03T10:54:06+08:00","dateModified":"2022-06-03T10:54:06+08:00","author":{"@type":"Person","name":"homily"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://homily707.github.io/posts/db/distribute-30/"},"publisher":{"@type":"Organization","name":"斯是陋室","logo":{"@type":"ImageObject","url":"https://homily707.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://homily707.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://homily707.github.io/tags/algo/ title=算法><span>算法</span></a></li><li><a href=https://homily707.github.io/tags/data/ title=数据库><span>数据库</span></a></li><li><a href=https://homily707.github.io/tags/k8s/ title=k8s><span>k8s</span></a></li><li><a href=https://homily707.github.io/tags/go/ title=go><span>go</span></a></li><li><a href=https://homily707.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://homily707.github.io/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://homily707.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://homily707.github.io/posts/>Posts</a></div><h1 class=post-title>分布式数据库笔记</h1><div class=post-meta><span title='2022-06-03 10:54:06 +0800 CST'>June 3, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;236 words&nbsp;·&nbsp;homily&nbsp;|&nbsp;<a href=https://github.com/homily707/homily707.github.io/issues rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#外部视角>外部视角</a></li><li><a href=#内部视角>内部视角</a></li><li><a href=#数据一致性>数据一致性</a></li><li><a href=#事务一致性>事务一致性</a><ul><li><a href=#隔离性>隔离性</a></li></ul></li><li><a href=#架构>架构</a></li><li><a href=#时钟>时钟</a></li><li><a href=#分片>分片</a></li><li><a href=#数据复制>数据复制</a><ul><li><a href=#元数据>元数据</a></li><li><a href=#复制效率>复制效率</a></li></ul></li></ul><ul><li><a href=#原子性>原子性</a><ul><li><a href=#2pc>2PC</a></li><li><a href=#事务延迟>事务延迟</a></li></ul></li><li><a href=#隔离性-1>隔离性</a><ul><li><a href=#悲观乐观>悲观、乐观</a></li></ul></li></ul><ul><li><ul><li><a href=#计算下推>计算下推</a></li></ul></li><li><a href=#查询引擎>查询引擎</a></li><li><a href=#rum>RUM</a><ul><li><a href=#b-tree>B tree</a></li><li><a href=#lsm-tree>LSM tree</a></li><li><a href=#wisckey>WiscKey</a></li></ul></li></ul></nav></div></details></div><div class=post-content><ul><li>存储的设计</li><li>事务模型</li><li>查询引擎</li><li>复制</li></ul><h1 id=基础篇>基础篇<a hidden class=anchor aria-hidden=true href=#基础篇>#</a></h1><h2 id=外部视角>外部视角<a hidden class=anchor aria-hidden=true href=#外部视角>#</a></h2><p>写多读少、低延时、高并发</p><p>海量并发（分布式和单体的区别）</p><p>高可靠</p><blockquote><p>rto 恢复时间 rpo 恢复点</p></blockquote><p>海量存储</p><h2 id=内部视角>内部视角<a hidden class=anchor aria-hidden=true href=#内部视角>#</a></h2><ol><li>客户端组件 + 单体 sharding jdbc</li><li>中间件 + 单体。 MyCat</li><li>应用层重构 + 单体</li></ol><h2 id=数据一致性>数据一致性<a hidden class=anchor aria-hidden=true href=#数据一致性>#</a></h2><p>状态一致性</p><ul><li>强一致：mysql 全同步复制</li><li>弱一致：eventually consistency</li></ul><p>操作一致性</p><ol><li><strong>写后读</strong>
写入成功，异步复制，保证写入者能读到</li><li>单调读
读过的数据，不会消失。将用户和副本建立映射关系。</li><li>前缀
保证事件复制的因果关系</li><li>线性一致性 Linearizability
所有操作可以比较先后顺序。通过全局时钟建立全序关系。
<strong>线性一致性是描述历史记录的，而不是描述系统的</strong>。我们可以判断访问系统获取的一系列历史记录，来判断这个结果是不是线性一致，从而判断这个系统是否能实现线性一致。</li><li>因果一致
逻辑时钟，建立不那么准确的 全序关系</li></ol><h2 id=事务一致性>事务一致性<a hidden class=anchor aria-hidden=true href=#事务一致性>#</a></h2><p>ACID</p><p>一致性：整体目标</p><p>持久性：数据丢失、故障容错。write ahead log， 多副本</p><h3 id=隔离性>隔离性<a hidden class=anchor aria-hidden=true href=#隔离性>#</a></h3><h4 id=异常现象>异常现象<a hidden class=anchor aria-hidden=true href=#异常现象>#</a></h4><p>幻读： T1 查询两次， T2插入。T1第2次读结果集增大</p><p>不可重复读： T1 查询两次， T2修改并提交。T1两次读结果不一致</p><p>脏读： T1 查询两次， T2修改但未提交。T1两次读结果不一致</p><h4 id=隔离级别>隔离级别<a hidden class=anchor aria-hidden=true href=#隔离级别>#</a></h4><p>未提交读： 脏读</p><p>已提交读： 不可重复读</p><p>可重复读： 会幻读</p><p>快照隔离： write skew</p><p>可串形化： 事务一个个执行</p><h2 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h2><ul><li>客户端通讯</li><li>查询处理器</li><li>事务管理器</li><li>进程管理器</li><li>辅助工具</li></ul><p>单体数据库</p><p>单体数据库（数据节点） + 协调节点 + 分片信息 + 全局时钟</p><p>newSql</p><p>计算节点 + 存储节点 + 全局时钟 + 元数据管理</p><h2 id=时钟>时钟<a hidden class=anchor aria-hidden=true href=#时钟>#</a></h2><p>spanner true time 物理时间 ，多时间源，多授时点</p><p>TIDB TSO 中心授时 逻辑时钟。</p><p>PD 组成raft组，提供授时服务，使用etcd + 预申请时间窗</p><h2 id=分片>分片<a hidden class=anchor aria-hidden=true href=#分片>#</a></h2><p>hash 、 一致性hash。（无法处理业务热点，无法范围查询）</p><p>range 静态</p><p>range 动态</p><ol><li>动态分裂、合并</li><li>通过调度实现存储均衡、压力均衡。减少分布式事务</li></ol><h2 id=数据复制>数据复制<a hidden class=anchor aria-hidden=true href=#数据复制>#</a></h2><h3 id=元数据>元数据<a hidden class=anchor aria-hidden=true href=#元数据>#</a></h3><p>TIKV 上node多个raft组存储分片信息。PD中心点读取kv心跳，获取当前分片信息。</p><h3 id=复制效率>复制效率<a hidden class=anchor aria-hidden=true href=#复制效率>#</a></h3><p>raft的半数同意会导致效率低，且操作是按顺序apply的</p><p>TIDB优化</p><ol><li>batch，多个请求一起发送</li><li>pipeline，nextIndex</li><li>parallelly，leader和follower的log并行apply</li><li>apply，异步执行</li></ol><h1 id=分布式事务>分布式事务<a hidden class=anchor aria-hidden=true href=#分布式事务>#</a></h1><h2 id=原子性>原子性<a hidden class=anchor aria-hidden=true href=#原子性>#</a></h2><p>TCC 应用层修改</p><h3 id=2pc>2PC<a hidden class=anchor aria-hidden=true href=#2pc>#</a></h3><p>事务管理器，在多个节点上先分别prepare，确认后再commit</p><p>问题：同步阻塞，事务管理器单点故障、commit失败数据不一致。</p><p>Precolator</p><p>使用mvcc，新增版本。在新版本上加主锁和次锁，次锁指向主锁。</p><p>commit，删掉主锁即可。次锁记录，lazy 加载，异步删除</p><h3 id=事务延迟>事务延迟<a hidden class=anchor aria-hidden=true href=#事务延迟>#</a></h3><p>延迟与写操作线性相关</p><ul><li>缓存提交写</li></ul><h2 id=隔离性-1>隔离性<a hidden class=anchor aria-hidden=true href=#隔离性-1>#</a></h2><p>MVCC。分布式中通过全局事务管理器，维护递增事务id、提供全局快照</p><p>存储方式</p><ul><li>append-only 存储在表中</li><li>delta，独立存储增量</li><li>timetravel，独立存储全量</li></ul><p>TIDB没有采用快照，读写阻塞</p><p>不确定的时间窗口。</p><p>spanner 写等待
cockroach 读等待</p><h3 id=悲观乐观>悲观、乐观<a hidden class=anchor aria-hidden=true href=#悲观乐观>#</a></h3><p>乐观 rcvw 读 算 验证 写</p><p>悲观 vrcw 验证 读 算 写
此处的读是拷贝加改写副本。写是提交</p><p>tidb乐观锁，虽然每一行都悲观的。但是整体事务是没有有效性验证</p><p>悲观，执行sql时，添加锁</p><h1 id=查询>查询<a hidden class=anchor aria-hidden=true href=#查询>#</a></h1><p><strong>存储过程</strong></p><p>难以调试</p><p><strong>自增主键</strong></p><ul><li>连续递增，事务回滚时会失效</li><li>单调递增，并发过大时会失效</li><li>尾部热点，</li></ul><p><strong>HTAP</strong></p><p>OLTP 和 OLAP 之间，需要ETL进行转换，存在时延。</p><p>TiFlash存储分离，flash 作为raft的一个learner。每次查询前找leader实现同步。</p><p>采用delta tree。</p><p><strong>Kappa</strong></p><p>kafka加stream计算，快速加工</p><h3 id=计算下推>计算下推<a hidden class=anchor aria-hidden=true href=#计算下推>#</a></h3><p>谓词下推</p><p>分区索引</p><p>全局索引</p><h2 id=查询引擎>查询引擎<a hidden class=anchor aria-hidden=true href=#查询引擎>#</a></h2><p>火山模型</p><p>向量化模型</p><p>代码生成</p><h2 id=rum>RUM<a hidden class=anchor aria-hidden=true href=#rum>#</a></h2><p>read update memory 三者不能同时优化</p><h3 id=b-tree>B tree<a hidden class=anchor aria-hidden=true href=#b-tree>#</a></h3><p>写放大，实际写比写的操作要多
存储不连续</p><h3 id=lsm-tree>LSM tree<a hidden class=anchor aria-hidden=true href=#lsm-tree>#</a></h3><p><strong>Tiered</strong></p><ol><li>先写内存，直接返回</li><li>内存 flush 进入 sstable</li><li>sstable compact 合并</li></ol><p>读放大，要同时读多个sstable</p><p>写放大，compact操作性能消耗很高</p><p><strong>leveled compact</strong></p><p>L0 可重叠</p><p>整理形成不重叠的L1</p><p>然后部分compact</p><h3 id=wisckey>WiscKey<a hidden class=anchor aria-hidden=true href=#wisckey>#</a></h3><p>value单独存储</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://homily707.github.io/tags/data/>data</a></li></ul><nav class=paginav><a class=prev href=https://homily707.github.io/posts/k8s/kubebuilder/><span class=title>« Prev</span><br><span>Kubebuilder</span></a>
<a class=next href=https://homily707.github.io/posts/algo/skiplist/><span class=title>Next »</span><br><span>跳表</span></a></nav></footer><script src=https://utteranc.es/client.js repo=homily707/homily707.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://homily707.github.io/>斯是陋室</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>